<% stages = [
  ["not_scheduled", "Not Scheduled"],
  ["install_removal", "Install / Removal"],
  ["scheduled_today", "Scheduled Today"],
  ["scheduled_tomorrow", "Scheduled Tomorrow"],
  ["parts_needed", "Parts Needed"],
  ["parts_ready", "Parts Ready To Go"],
  ["repair_complete", "Repair Complete"]
] %>

<div class="mb-4 flex items-center justify-between">
  <h1 class="text-xl font-semibold">Ticket Board</h1>
  <div class="space-x-2">
    <%= link_to "Back to List", tickets_path, class: "inline-flex items-center rounded-md border border-gray-700 px-3 py-2 text-sm font-semibold text-gray-100 hover:bg-gray-800" %>
    <%= link_to "New Ticket", new_ticket_path, class: "inline-flex items-center rounded-md bg-indigo-600 px-3 py-2 text-sm font-semibold text-white shadow-sm hover:bg-indigo-500" %>
  </div>
</div>

<div id="board-error" class="mb-3 hidden rounded-md border border-red-800 bg-red-900/60 px-4 py-2 text-sm text-red-200"></div>

<!-- Modal Overlay -->
<div id="ticket-modal" class="fixed inset-0 z-50 hidden items-center justify-center">
  <div class="absolute inset-0 bg-black/70" onclick="closeModal()"></div>
  <div class="relative z-10 w-[95vw] max-w-4xl max-h-[90vh] overflow-auto rounded-lg border border-gray-700 bg-gray-900 p-4">
    <div class="flex items-center justify-between mb-3">
      <h3 class="text-lg font-semibold text-gray-100">Ticket</h3>
      <button class="rounded bg-gray-800 px-3 py-1 text-sm text-gray-200 hover:bg-gray-700" onclick="closeModal()">Close</button>
    </div>
    <div id="ticket-modal-body" class="prose prose-invert max-w-none">
      <!-- ticket details will be loaded here -->
    </div>
  </div>
</div>

<!-- Board with sticky headers and comfortable height -->
<div id="board-scroll" class="overflow-x-auto select-none pb-10">
  <div class="flex gap-4 min-w-max">
    <% @tickets_by_stage ||= {} %>
    <% stages.each do |value, label| %>
      <section class="flex-none w-80 rounded-lg border border-gray-700 bg-gray-800">
        <header class="sticky top-0 z-10 border-b border-gray-700 bg-gray-800/95 px-3 py-2 backdrop-blur">
          <h2 class="text-sm font-semibold text-gray-200"><%= label %></h2>
        </header>
        <ul
          class="max-h-[78vh] min-h-[65vh] overflow-y-auto space-y-2 p-3 transition ring-0"
          data-stage="<%= value %>"
          ondragover="columnDragOver(event)"
          ondragenter="columnEnter(event)"
          ondragleave="columnLeave(event)"
          ondrop="dropOnColumn(event)"
        >
          <% (@tickets_by_stage[value] || []).each do |ticket| %>
            <li
              id="ticket-<%= ticket.id %>"
              class="group cursor-grab rounded-md border border-gray-600 bg-gray-700 p-3 shadow-sm transition hover:ring-2 hover:ring-indigo-600/50"
              draggable="true"
              ondragstart="dragStart(event)"
              ondragend="dragEnd(event)"
              ondragover="cardDragOver(event)"
              ondragleave="cardDragLeave(event)"
              onclick="cardClick(event)"
              onkeydown="cardKeydown(event)"
              role="button"
              tabindex="0"
              data-ticket-id="<%= ticket.id %>"
              data-url="<%= ticket_path(ticket, modal: 1) %>"
            >
              <div class="flex items-center justify-between">
                <div class="text-sm font-medium text-gray-100"><%= ticket.account_name %></div>
                <span class="text-xs text-gray-400">#<%= ticket.id %></span>
              </div>
              <div class="mt-1 text-xs text-gray-300">
                <span class="font-medium">City:</span> <%= ticket.city %>
              </div>
              <div class="mt-1 text-xs">
                <% color = { "high"=>"bg-red-900/50 text-red-300", "medium"=>"bg-yellow-900/50 text-yellow-300", "low"=>"bg-gray-600 text-gray-200" }[ticket.priority] || "bg-gray-600 text-gray-200" %>
                <span class="mr-2 text-gray-300">Priority:</span>
                <span class="inline-flex items-center rounded-full px-2 py-0.5 font-medium <%= color %>"><%= ticket.priority.humanize %></span>
                <% if ticket.stage == "repair_complete" %>
                  <span class="ml-2 inline-flex items-center rounded-full bg-green-900/50 px-2 py-0.5 text-xs font-medium text-green-300">Completed</span>
                <% end %>
              </div>
              <div class="mt-2 text-xs text-gray-400">
                Click card to open â€¢ Drag to re-order/move
              </div>
            </li>
          <% end %>

          <li class="hidden drop-hint rounded border border-dashed border-indigo-700/60 bg-indigo-900/20 p-2 text-center text-xs text-indigo-300">
            Drop here
          </li>
        </ul>
      </section>
    <% end %>
  </div>
</div>

<script>
    let draggedId = null;
    let previousParent = null;
    let dragStartedAt = 0;
    let dropBeforeId = null;
    let autoScrollTimer = null;
    let lastPointerX = 0;
    let lastPointerY = 0;
    let lastUL = null;

    // Modal helpers
    function openModal(html) {
        const body = document.getElementById("ticket-modal-body");
        body.innerHTML = html;
        const modal = document.getElementById("ticket-modal");
        modal.classList.remove("hidden");
        modal.classList.add("flex");
    }
    function closeModal() {
        const modal = document.getElementById("ticket-modal");
        modal.classList.add("hidden");
        modal.classList.remove("flex");
        document.getElementById("ticket-modal-body").innerHTML = "";
    }

    // Intercept clicks inside modal for links marked for modal flow
    document.getElementById("ticket-modal-body").addEventListener("click", function(e) {
        const a = e.target.closest("a");
        if (!a) return;
        const isModalLink = a.dataset.modal === "1" || (a.getAttribute("href") || "").includes("modal=1");
        if (!isModalLink) return;

        e.preventDefault();
        fetch(a.href, { headers: { "X-Requested-With": "XMLHttpRequest", "Accept": "text/html" }})
            .then(r => r.text())
            .then(html => openModal(html))
            .catch(() => showBoardError("Failed to load"));
    });

    // Intercept form submits from modal edit (keeps flow in modal)
    document.getElementById("ticket-modal-body").addEventListener("submit", function(e) {
        const form = e.target.closest("form");
        if (!form) return;
        const hasModalParam = form.querySelector("input[name='modal'][value='1']");
        if (!hasModalParam) return;

        e.preventDefault();
        fetch(form.action, {
            method: (form.method || "POST").toUpperCase(),
            headers: { "X-Requested-With": "XMLHttpRequest", "Accept": "text/html" },
            body: new FormData(form)
        })
            .then(async r => {
                const html = await r.text();
                openModal(html); // show updated ticket or re-render edit with errors
            })
            .catch(() => showBoardError("Failed to submit form"));
    });

    // Persist horizontal scroll
    (function restoreBoardScroll() {
        const scroller = document.getElementById("board-scroll");
        if (!scroller) return;
        const saved = localStorage.getItem("board.scrollLeft");
        if (saved) scroller.scrollLeft = parseInt(saved, 10);
        scroller.addEventListener("scroll", () => {
            localStorage.setItem("board.scrollLeft", String(scroller.scrollLeft));
        });
    })();

    function showBoardError(msg) {
        const box = document.getElementById("board-error");
        if (!box) return;
        box.textContent = msg;
        box.classList.remove("hidden");
        setTimeout(() => box.classList.add("hidden"), 4000);
    }

    function setDraggingStyles(el, dragging) {
        if (!el) return;
        if (dragging) {
            el.classList.add("opacity-60", "ring-2", "ring-indigo-500", "cursor-grabbing", "scale-[0.99]");
            el.classList.remove("cursor-grab");
        } else {
            el.classList.remove("opacity-60", "ring-2", "ring-indigo-500", "cursor-grabbing", "scale-[0.99]");
            el.classList.add("cursor-grab");
        }
    }

    function toggleDropStyles(ul, on) {
        if (!ul) return;
        const hint = ul.querySelector(".drop-hint");
        if (on) {
            ul.classList.add("ring", "ring-indigo-700/60", "bg-indigo-900/10");
            if (hint) hint.classList.remove("hidden");
        } else {
            ul.classList.remove("ring", "ring-indigo-700/60", "bg-indigo-900/10");
            if (hint) hint.classList.add("hidden");
        }
    }

    function dragStart(e) {
        const el = e.currentTarget;
        draggedId = el.dataset.ticketId;
        previousParent = el.parentElement;
        e.dataTransfer.effectAllowed = "move";
        e.dataTransfer.setData("text/plain", draggedId);
        dragStartedAt = Date.now();
        setDraggingStyles(el, true);
    }

    function dragEnd(e) {
        setDraggingStyles(e.currentTarget, false);
        document.querySelectorAll("ul[data-stage]").forEach(ul => toggleDropStyles(ul, false));
        document.querySelectorAll("li[id^='ticket-']").forEach(card => card.classList.remove("ring", "ring-indigo-500"));
        stopAutoScroll();
        draggedId = null;
        previousParent = null;
        dragStartedAt = 0;
        dropBeforeId = null;
        lastUL = null;
    }

    // Update pointer coordinates constantly and (re)start auto-scroll loop
    function columnDragOver(e) {
        e.preventDefault();
        const ul = e.currentTarget;
        lastPointerX = e.clientX;
        lastPointerY = e.clientY;
        lastUL = ul;
        toggleDropStyles(ul, true);
        startAutoScroll();
    }

    function columnEnter(e) {
        toggleDropStyles(e.currentTarget, true);
    }

    function columnLeave(e) {
        if (!e.currentTarget.contains(e.relatedTarget)) {
            toggleDropStyles(e.currentTarget, false);
        }
    }

    function cardDragOver(e) {
        e.preventDefault();
        const card = e.currentTarget;
        dropBeforeId = card.dataset.ticketId;
        card.classList.add("ring", "ring-indigo-500");
    }

    function cardDragLeave(e) {
        const card = e.currentTarget;
        card.classList.remove("ring", "ring-indigo-500");
        if (!card.contains(e.relatedTarget) && dropBeforeId === card.dataset.ticketId) {
            dropBeforeId = null;
        }
    }

    function cardClick(e) {
        if (draggedId) return;
        if (dragStartedAt && (Date.now() - dragStartedAt) < 150) return;

        const url = e.currentTarget?.dataset?.url;
        if (!url) return;

        fetch(url, { headers: { "X-Requested-With": "XMLHttpRequest", "Accept": "text/html" }})
            .then(r => r.text())
            .then(html => openModal(html))
            .catch(() => showBoardError("Failed to load ticket"));
    }

    function cardKeydown(e) {
        if ((e.key === "Enter" || e.key === " ") && !draggedId) {
            e.preventDefault();
            cardClick({ currentTarget: e.currentTarget });
        }
    }

    function computePositionIndex(ul) {
        const ids = Array.from(ul.querySelectorAll("li[id^='ticket-']")).map(li => li.dataset.ticketId);
        return ids.indexOf(draggedId) + 1;
    }

    async function dropOnColumn(e) {
        e.preventDefault();
        const ul = e.currentTarget;
        toggleDropStyles(ul, false);
        stopAutoScroll();

        const stage = ul.dataset.stage;
        if (!draggedId) return;

        const el = document.getElementById(`ticket-${draggedId}`);

        if (dropBeforeId) {
            const beforeEl = document.getElementById(`ticket-${dropBeforeId}`);
            if (beforeEl && beforeEl.parentElement === ul) {
                ul.insertBefore(el, beforeEl);
            } else {
                ul.appendChild(el);
            }
        } else {
            ul.appendChild(el);
        }

        document.querySelectorAll("li[id^='ticket-']").forEach(card => card.classList.remove("ring", "ring-indigo-500"));

        try {
            const position = computePositionIndex(ul);
            const resp = await fetch(`/tickets/${draggedId}/stage`, {
                method: "PATCH",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json",
                    "X-CSRF-Token": document.querySelector("meta[name='csrf-token']").content
                },
                body: JSON.stringify({ stage, position })
            });
            if (!resp.ok) {
                const data = await resp.json().catch(() => ({}));
                if (previousParent && el) previousParent.appendChild(el);
                showBoardError(data.error || "Failed to update stage/position");
            }
        } catch (err) {
            console.error(err);
            if (previousParent && el) previousParent.appendChild(el);
            showBoardError("Network error updating stage");
        } finally {
            setDraggingStyles(el, false);
            draggedId = null;
            previousParent = null;
            dragStartedAt = 0;
            dropBeforeId = null;
            lastUL = null;
        }
    }

    // ---------- Auto-scroll improvements (top & edges) ----------
    function startAutoScroll() {
        if (autoScrollTimer) return; // already running
        autoScrollTimer = setInterval(() => {
            if (!lastUL) return;

            const board = document.getElementById("board-scroll");
            const viewportH = window.innerHeight;
            const viewportW = window.innerWidth;

            // Edges and speeds
            const edgeV = 120; // generous vertical threshold
            const edgeH = 80;  // horizontal threshold
            const fastBandV = 40; // faster near top/bottom
            const vBase = 12;
            const hBase = 16;

            const ulRect = lastUL.getBoundingClientRect();

            // Window vertical
            let scrollDown = lastPointerY > (viewportH - edgeV);
            let scrollUp   = lastPointerY < edgeV;

            // Column internal vertical
            let colDown = lastPointerY > (ulRect.bottom - 80);
            let colUp   = lastPointerY < (ulRect.top + 100);

            // Board horizontal
            let scrollRight = lastPointerX > (viewportW - edgeH);
            let scrollLeft  = lastPointerX < edgeH;

            let vSpeed = vBase;
            if (lastPointerY < fastBandV || lastPointerY > (viewportH - fastBandV)) vSpeed = vBase * 1.8;

            if (scrollDown) window.scrollBy(0, vSpeed);
            if (scrollUp)   window.scrollBy(0, -vSpeed);

            if (lastUL) {
                if (colDown) lastUL.scrollTop += vSpeed;
                if (colUp)   lastUL.scrollTop -= vSpeed;
            }

            if (board) {
                if (scrollRight) board.scrollLeft += hBase;
                if (scrollLeft)  board.scrollLeft -= hBase;
            }
        }, 16);
    }

    function stopAutoScroll() {
        if (autoScrollTimer) {
            clearInterval(autoScrollTimer);
            autoScrollTimer = null;
        }
    }
</script>